// A Boogie program is a set of declaration. 
Program ::= Declaration*;

// Declaration
abstract Declaration ::= Identifier:Identifier Attributes:Attribute*;

Attribute ::= <Label:String> [Argument:Expression];

// Type declaration
abstract TypeDeclaration : Declaration ::= Arguments:TypeArgument*;

TypeConstructor : TypeDeclaration ::= <Finite:Boolean>;

TypeSynonym : TypeDeclaration ::= Alias:Type;

Identifier ::= <Label:String>;

// Constant declaration
ConstantDeclaration : Declaration ::= <Unique:Boolean> OrderSpecification;

OrderSpecification ::= Edges:ParentEdge* <Complete:Boolean>;

ParentEdge ::= <Unique:Boolean> Parent:Constant;

Constant ::= Identifier;

// Function declaration
FunctionDeclaration ::= FunctionSignature;

FunctionSignature ::= TypeArguments:TypeArgument* FunctionArguments:Binding* ReturnArgument:Binding;

// Axiom declaration
AxiomDeclaration : Declaration ::= Expression;

// Variable declaration
VariableDeclaration : Declaration ::= Variables:Binding* [WhereClause];

WhereClause ::= Expression;

// Procedure declaration
ProcedureDeclaration : Declaration ::= Signature:ProcedureSignature Conditions:Specification* [Body];

ProcedureSignature ::= TypeArguments:TypeArgument* InputParameters:Binding* OutputParameters:Binding*;

// Implementation declaration
ImplementationDeclaration : ProcedureDeclaration ::= Body;

LocalVariableDeclaration : Declaration ::= Variables:Binding*;

Body ::= LocalVariables:LocalVariableDeclaration* Statements:Statement*;

// Expressions
abstract Meta;

Star : Meta;

abstract Expression : Meta;

abstract BinaryExpression : Expression ::= LeftOperand:Expression RightOperand:Expression;

abstract UnaryExpression: Expression ::= Operand:Expression;

// Boolean expressions
EquivalenceOperation : BinaryExpression;

ImplicationOperation : BinaryExpression;

OrOperation : BinaryExpression;

AndOperation : BinaryExpression;

NegationOperation : UnaryExpression;

// Relational expressions
EqualsOperation : BinaryExpression;

NotEqualsOperation : BinaryExpression;

LessThanOperation : BinaryExpression;

GreaterThanOperation : BinaryExpression;

LessThanEqualsOperation : BinaryExpression;

GreaterThanEqualsOperation : BinaryExpression;

PartialOrderOperation : BinaryExpression;

// Arithmetic expressions
AdditionOperation : BinaryExpression;

SubtractionOperation : BinaryExpression;

MultiplicationOperation : BinaryExpression;

DivisionOperation : BinaryExpression;

ModuloOperation : BinaryExpression;

MinusOperation : UnaryExpression;

// Vector expressions
ConcatenationOperation : BinaryExpression;

// Map expressions
MapAccessOperation : UnaryExpression ::= Indexes:Expression*;

MapRangedAccessOperation : UnaryExpression ::= <RangeStart:Integer> <RangeEnd:Integer>;

MapUpdateOperation : MapAccessOperation ::= Update:Expression;

// Quantifier expressions
abstract QuantifierExpression : UnaryExpression ::= TypeArguments:TypeArgument* Parameters:Binding* Triggers:Expression*;

UniversalQuantifier : QuantifierExpression;

ExistentialQuantifier : QuantifierExpression;

// Symbolic reference
SymbolicReference : Expression ::= Name:Identifier;

FunctionCall : SymbolicReference ::= Arguments:Expression*;

// Literal expressions
abstract Literal : Expression;

NumberLiteral : Literal ::= <Value:Integer>;

BitVectorLiteral : Literal ::= <Value:Integer> <Size:Integer>;

StringLiteral : Literal ::= <Value:String>;

BoolLiteral : Literal ::= <Value:Boolean>;

RealLiteral : Literal ::= <Value:String>;

// Statements
abstract Statement ::= Label:Identifier;

AssertStatement : Statement ::= Expression;

AssumeStatement : Statement ::= Expression;

HavocStatement : Statement ::= SymbolicReference*;

AssignmentStatement : Statement ::= Targets:SymbolicReference* Source:Expression*;

abstract CallStatement : Statement ::= Callee:Identifier;

TargetedCallStatement : CallStatement ::= Targets:SymbolicReference* Arguments:Expression*;

ForAllCallStatement : CallStatement ::= Arguments:Meta*;

IfStatement : Statement ::= Condition:Meta Then:BlockStatement [Else:BlockStatement];

WhileStatement : Statement ::= Condition:Meta Statement;

BreakStatement : Statement ::= [Label:Identifier];

ReturnStatement : Statement;

GotoStatement : Statement ::= [Label:Identifier];

BlockStatement : Statement ::= Statement*;

// Specifications
abstract Specification ::= <Free:Boolean>;

PreCondition ::= Expression;

PostCondition ::= Expression;

FrameCondition ::= SymbolicReference*;

LoopInvariant ::= Expression;

// Types
abstract Type;

BoolType : Type;

IntegerType : Type;

RealType : Type;

BitVectorType : Type ::= <Size:Integer>;

ConstructedType : Type ::= Name:Identifier Arguments:Type*;

MapType : Type ::= Arguments:TypeArgument* KeyTypes:Type* ValueType:Type;

TypeArgument ::= Name:Identifier;

Binding ::= Name:Identifier Type;
