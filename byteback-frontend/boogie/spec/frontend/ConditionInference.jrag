import java.util.Stack;
import java.util.HashSet;
import java.util.Set;

/**
 * Functions used to automatically infer `modify` conditions from the
 * assignments of global variables in the program.
 * 
 * @author paganma
 */
aspect ConditionInference {

	/**
	 * Adds a frame condition to this procedure, and to all the
	 * procedures that may call this procedure in the program.
	 *
	 * The function performs a BFS starting from this procedure, and
	 * considers a node "visited" if it already presents the frame
	 * condition. As such, calling this function multiple times on the
	 * same variable will not add more than one frame condition to the
	 * call-tree.
	 *
	 * @param modified The variable that is being modified by this procedure.
	 */
	public void Procedure.propagateModifies() {
		final Stack<Procedure> next = new Stack<>();

		for (ValueReference reference : frameConditions()) {
			final Variable modified = reference.getAccessor().lookupRemoteVariable().orElse(null);

			if (modified == null) {
				continue;
			}
			
			final FrameCondition condition = new FrameCondition(false, new List<>(modified.makeValueReference()));
			next.push(this);

			while (!next.isEmpty()) {
				final Procedure procedure = next.pop();

				for (Procedure caller : procedure.callers()) {
					if (!caller.modifies(modified)) {
						final ProcedureDeclaration declaration = caller.getProcedureDeclaration();
						declaration.addSpecification(condition.treeCopy());
						next.push(caller);
					}
				}
			}
		}
	}

	/**
	 * Infer frame conditions for procedures that are modifying global
	 * variables in this program.
	 */
	public void Program.propagateModifies() {
		for (Procedure procedure : procedures()) {
			procedure.propagateModifies();
		}
	}
	
}
