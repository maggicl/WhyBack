import java.util.Optional;
import java.util.LinkedList;

aspect Function {

  /**
   * Scope collection.
   */
  coll EntityTable<Function> Program.functions();

  FunctionDeclaration contributes getFunction() to Program.functions();

  /**
   * NTA definitions.
   */
  syn nta Function FunctionDeclaration.getFunction();

  eq FunctionDeclaration.getFunction() = new Function(getDeclarator());

  /**
   * Looking up functions.
   */
  syn lazy Optional<Function> Accessor.function();

  eq Accessor.function() = lookupFunction(getName());

  inh lazy Optional<Function> Accessor.lookupFunction(String name);

  eq Program.getChild().lookupFunction(String name) = lookupFunction(name);

  syn lazy Optional<Function> Program.lookupFunction(String name);

  eq Program.lookupFunction(String name) = functions().getFirst(name);

  /**
   * Get declaration from function entity.
   */
  inh lazy FunctionDeclaration Function.getFunctionDeclaration();

  eq FunctionDeclaration.getChild().getFunctionDeclaration() = this;

  /**
   * Create a function reference with unbound arguments.
   */
  syn FunctionReference Function.makeFunctionReference();

  eq Function.makeFunctionReference() = new FunctionReference(getDeclarator().makeAccessor(), new List<>());

  /**
   * Function inlining.
   */
  syn Expression Function.inline(List<Expression> arguments);

  eq Function.inline(List<Expression> arguments) {
    // Collections cannot be populated in an unrooted tree, therefore
    // we need to manually create a new root.
    final Program program = new Program();
    final FunctionDeclaration declaration = getFunctionDeclaration().fullCopy();

    program.addDeclaration(declaration);

    for (Variable variable : declaration.getFunction().variables()) {
      if (arguments.getNumChild() == 0) {
        throw new IllegalArgumentException("Argument count does not match");
      }

      final Expression argument = arguments.getChild(0);
      arguments.removeChild(0);

      for (ValueReference reference : variable.references()) {
        final ASTNode parent = reference.getParent();
        final int index = parent.getIndexOfChild(reference);
        parent.setChild(argument.fullCopy(), index);
      }
    }

    final Expression inlinedExpression = declaration.getExpression();
    inlinedExpression.setParent(null);

    return inlinedExpression;
  }

  /**
   * Inline at callsite.
   */
  syn Expression FunctionReference.inline();

  eq FunctionReference.inline() = getAccessor().function()
    .orElseThrow(() -> new RuntimeException("Unresolved function reference"))
    .inline(getArgumentList());

}
