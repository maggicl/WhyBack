import java.util.LinkedList;

aspect Variable {

  interface Scope {
    EntityTable<Variable> variables();
  }

  Program implements Scope;

  Function implements Scope;

  Procedure implements Scope;

  Implementation implements Scope;

  Body implements Scope;

  /**
   * Scope collections
   */
  coll EntityTable<Variable> Scope.variables();

  Binding contributes
    each getVariableList() to Scope.variables()
    for getScope();

  inh Scope Binding.getScope();

  eq Program.getChild().getScope() = this;

  eq FunctionDeclaration.getChild().getScope() = getFunction();

  eq ProcedureDeclaration.getChild().getScope() = getProcedure();

  eq ImplementationDeclaration.getChild().getScope() = getImplementation();

  eq Body.getChild().getScope() = this;

  /**
   * References collection.
   */
  coll LinkedList<ValueReference> Variable.references();

  // We might want to keep track of unresolved references in a separate collection
  ValueReference contributes
    this when getAccessor().variable().isPresent() to Variable.references()
    for getAccessor().variable().get();

  /**
   * Assignments collection
   */
  coll LinkedList<AssignmentStatement> Variable.assignments();

  AssignmentStatement contributes
    this to Variable.assignments()
    for getTarget().getAccessor().variable().orElse(null);

  /**
   * NTA definitions.
   */
  syn nta List<Variable> Binding.getVariableList();
    
  eq OptionalBinding.getVariableList() {
    final List<Variable> variables = new List<>();

    if (hasDeclarator()) {
      variables.add(new Variable(getDeclarator()));
    }

    return variables;
  }

  eq SetBinding.getVariableList() {
    final List<Variable> variables = new List<>();

    for (Declarator declarator : getDeclaratorList()) {
      variables.add(new Variable(declarator));
    }

    return variables;
  }

  /**
   * Lookup variables locally.
   */
  syn lazy Optional<Variable> Scope.lookupLocalVariable(String name);

  eq Scope.lookupLocalVariable(String name) = variables().getFirst(name);

  /**
   * Lookup variables remotely.
   */
  eq Program.getChild().lookupRemoteVariable(String name) {
    return lookupLocalVariable(name);
  }

  inh lazy Optional<Variable> FunctionDeclaration.lookupRemoteVariable(String name);

  eq FunctionDeclaration.getChild().lookupRemoteVariable(String name) {
    final Optional<Variable> localLookup = getFunction().lookupLocalVariable(name);

    if (!localLookup.isPresent()) {
      return lookupRemoteVariable(name);
    } else {
      return localLookup;
    }
  }

  inh lazy Optional<Variable> ProcedureDeclaration.lookupRemoteVariable(String name);

  eq ProcedureDeclaration.getChild().lookupRemoteVariable(String name) {
    final Optional<Variable> localLookup = getProcedure().lookupLocalVariable(name);

    if (!localLookup.isPresent()) {
      return lookupRemoteVariable(name);
    } else {
      return localLookup;
    }
  }

  inh lazy Optional<Variable> Body.lookupRemoteVariable(String name);

  eq Body.getChild().lookupRemoteVariable(String name) {
    final Optional<Variable> localLookup = lookupLocalVariable(name);

    if (!localLookup.isPresent()) {
      return lookupRemoteVariable(name);
    } else {
      return localLookup;
    }
  }

  inh lazy Optional<Variable> Accessor.lookupRemoteVariable(String name);

  syn lazy Optional<Variable> Accessor.variable();

  eq Accessor.variable() = lookupRemoteVariable(getName());

  /**
   * Get type access used in variable.
   */
  inh lazy TypeAccess Variable.getTypeAccess();

  eq Binding.getVariable().getTypeAccess() = getTypeAccess();

  /**
   * Get reference to variable.
   */
  syn ValueReference Variable.makeValueReference();

  eq Variable.makeValueReference() = new ValueReference(getDeclarator().makeAccessor());

  /**
   * Create optional binding from variable.
   */
  syn OptionalBinding Variable.makeOptionalBinding();

  eq Variable.makeOptionalBinding() = new OptionalBinding(getTypeAccess(), new Opt(getDeclarator()));

  /**
   * Fetch the constant declaration of the variable, if it has been defined as such.
   */
  inh lazy Optional<ConstantDeclaration> Variable.getConstantDeclaration();

  eq ConstantDeclaration.getBinding().getConstantDeclaration() = Optional.of(this);

  eq Program.getChild().getConstantDeclaration() = Optional.empty();

  inh lazy Optional<VariableDeclaration> Variable.getVariableDeclaration();

  eq VariableDeclaration.getBinding().getVariableDeclaration() = Optional.of(this);

  eq Program.getChild().getVariableDeclaration() = Optional.empty();

  /**
   * Create variable declaration from reference.
   */
  syn VariableDeclaration ValueReference.makeVariableDeclaration(TypeAccess typeAccess);

  eq ValueReference.makeVariableDeclaration(TypeAccess typeAccess) =
    new VariableDeclaration(new List<>(), new List<>(new BoundedBinding(
      typeAccess, new List<>(getAccessor().makeDeclarator()), new Opt<>())));

  /**
   * Delete a variable and all of its assignments.
   */
  public void Variable.delete() {
    assert references().size() == 0 : "Only unreferenced variables can be deleted";

    for (AssignmentStatement statement : assignments()) {
      statement.delete();
    }

    getVariableDeclaration().get().delete();
  }

}
