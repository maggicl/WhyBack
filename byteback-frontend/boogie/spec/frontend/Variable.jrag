import java.util.LinkedList;

aspect Variable {

  interface Scope {
    EntityTable<Variable> variables();
  }

  Program implements Scope;

  Function implements Scope;

  Procedure implements Scope;

  Implementation implements Scope;

  Body implements Scope;

  /**
   * Scope collections
   */
  coll EntityTable<Variable> Scope.variables();

  Binding contributes
    each getVariableList() to Scope.variables()
    for getScope();

  inh Scope Binding.getScope();

  eq Program.getChild().getScope() = this;

  eq FunctionDeclaration.getChild().getScope() = getFunction();

  eq ProcedureDeclaration.getChild().getScope() = getProcedure();

  eq ImplementationDeclaration.getChild().getScope() = getImplementation();

  eq Body.getChild().getScope() = this;

  /**
   * References collection.
   */
  coll LinkedList<ValueReference> Variable.references();

  // We might want to keep track of unresolved references in a separate collection
  ValueReference contributes this to Variable.references() for getAccessor().lookupVariable().orElse(null);

  /**
   * NTA definitions.
   */
  syn nta List<Variable> Binding.getVariableList();
    
  eq OptionalBinding.getVariableList() {
    final List<Variable> variables = new List<>();

    if (hasDeclarator()) {
      variables.add(new Variable(getDeclarator()));
    }

    return variables;
  }

  eq SetBinding.getVariableList() {
    final List<Variable> variables = new List<>();

    for (Declarator declarator : getDeclaratorList()) {
      variables.add(new Variable(declarator));
    }

    return variables;
  }

  /**
   * Lookup variables in program.
   */
  syn lazy Optional<Variable> Program.lookupVariable(String name);

  eq Program.lookupVariable(String name) = variables().getFirst(name);

  syn lazy Optional<Variable> Function.lookupVariable(String name);

  eq Function.lookupVariable(String name) = variables().getFirst(name);

  syn lazy Optional<Variable> Accessor.lookupVariable();

  eq Accessor.lookupVariable() = lookupVariable(getName());

  inh lazy Optional<Variable> Accessor.lookupVariable(String name);

  eq Program.getChild().lookupVariable(String name) = lookupVariable(name);

  eq FunctionDeclaration.getChild().lookupVariable(String name) = getFunction().lookupVariable(name);

  /**
   * Get type access used in variable.
   */
  inh lazy TypeAccess Variable.getTypeAccess();

  eq Binding.getVariable().getTypeAccess() = getTypeAccess();

  /**
   * Get reference to variable.
   */
  syn ValueReference Variable.getValueReference();

  eq Variable.getValueReference() = new ValueReference(getDeclarator().getAccessor());

  /**
   * Create optional binding from variable.
   */
  syn OptionalBinding Variable.makeOptionalBinding();

  eq Variable.makeOptionalBinding() = new OptionalBinding(getTypeAccess(), new Opt(getDeclarator()));

  /**
   * Fetch the constant declaration of the variable, if it has been defined as such.
   */
  inh lazy Optional<ConstantDeclaration> Variable.getConstantDeclaration();

  eq ConstantDeclaration.getBinding().getConstantDeclaration() = Optional.of(this);

  eq Program.getChild().getConstantDeclaration() = Optional.empty();

}
