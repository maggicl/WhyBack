// A Boogie program is a set of declarations 
Program ::= Declaration*;

// Declaration
abstract Declaration ::= Attributes:Attribute*;

Attribute ::= <Name:String> Arguments:Expression*;

// Declarator
abstract Declarator ::= <Name:String>;

abstract GlobalDeclarator : Declarator;

abstract LocalDeclarator : Declarator;

// Binding
abstract Binding ::= TypeAccessor:TypeAccessor;

BoundedBinding : Binding ::= [WhereClause];

WhereClause ::= Expression;

// Access
abstract Accessor;

TypeAccessor : Accessor ::= Type:Type;

abstract SymbolicAccessor : Accessor ::= <Name:String>;

FunctionAccessor : SymbolicAccessor;

ProcedureAccessor : SymbolicAccessor; 

// Type variable
TypeVariable ::= <Identifier:String>;

// Types
abstract Type;

BoolType : Type;

IntegerType : Type;

RealType : Type;

BitVectorType : Type ::= <Size:Integer>;

UnknownType : Type ::= <Name:String> TypeParameters:TypeAccessor*;

MapType : Type ::= TypeArguments:TypeVariable* KeyTypes:TypeAccessor* ValueType:TypeAccessor;

// Type declaration
abstract TypeDeclaration : Declaration ::= Declarator:TypeDeclarator TypeArguments:TypeVariable*;

TypeDeclarator : GlobalDeclarator;

TypeConstructor : TypeDeclaration ::= <Finite:Boolean>;

TypeSynonym : TypeDeclaration ::= Aliased:TypeAccessor;

// Constant declaration
ConstantDeclaration : Declaration ::= Declarators:ConstantDeclarator* <Unique:Boolean> OrderSpecification;

ConstantDeclarator : GlobalDeclarator;

OrderSpecification ::= Edges:ParentEdge* <Complete:Boolean>;

ParentEdge ::= <Unique:Boolean> <ParentConstant:String>;

// Axiom declaration
AxiomDeclaration : Declaration ::= Declarator:AxiomDeclarator Expression:Expression;

AxiomDeclarator : GlobalDeclarator;

// Global variable declaration
GlobalVariableDeclaration : Declaration ::= Binding:GlobalVariableBinding;

GlobalVariableBinding : BoundedBinding ::= Declarators:GlobalVariableDeclarator*;

GlobalVariableDeclarator : GlobalDeclarator;

// Local variable declaration
LocalVariableDeclaration : Declaration ::= Declarators:LocalVariableDeclarator*;

LocalVariableBinding : BoundedBinding ::= Declarators:LocalVariableDeclarator*;

LocalVariableDeclarator : Declarator;

// Function declaration
FunctionDeclaration ::= Declarator:FunctionDeclarator Signature:FunctionSignature;

FunctionDeclarator : GlobalDeclarator;

FunctionSignature ::= TypeArguments:TypeVariable* FunctionArguments:FunctionBinding* ReturnArgument:FunctionBinding;

FunctionBinding : Binding ::= [Declarator:ParameterDeclarator];

ParameterDeclarator : LocalDeclarator;

// Procedure declaration
ProcedureDeclaration : Declaration ::= Declarator:ProcedureDeclarator Signature:ProcedureSignature Conditions:Specification* [Body];

ProcedureDeclarator : Declarator;

ProcedureSignature ::= TypeArguments:TypeVariable* InputParameters:ProcedureBinding* OutputParameters:ProcedureBinding*;

ProcedureBinding : BoundedBinding ::= Declarators:ProcedureDeclarator*;

// Implementation declaration
ImplementationDeclaration : ProcedureDeclaration ::= Body;

Body ::= LocalVariables:LocalVariableDeclaration* Statements:Statement*;

// Expressions
abstract Meta;

Star : Meta;

abstract Expression : Meta;

abstract BinaryExpression : Expression ::= LeftOperand:Expression RightOperand:Expression;

abstract UnaryExpression: Expression ::= Operand:Expression;

// Boolean expressions
EquivalenceOperation : BinaryExpression;

ImplicationOperation : BinaryExpression;

OrOperation : BinaryExpression;

AndOperation : BinaryExpression;

NegationOperation : UnaryExpression;

// Relational expressions
EqualsOperation : BinaryExpression;

NotEqualsOperation : BinaryExpression;

LessThanOperation : BinaryExpression;

GreaterThanOperation : BinaryExpression;

LessThanEqualsOperation : BinaryExpression;

GreaterThanEqualsOperation : BinaryExpression;

PartialOrderOperation : BinaryExpression;

// Arithmetic expressions
AdditionOperation : BinaryExpression;

SubtractionOperation : BinaryExpression;

MultiplicationOperation : BinaryExpression;

DivisionOperation : BinaryExpression;

ModuloOperation : BinaryExpression;

MinusOperation : UnaryExpression;

// Vector expressions
ConcatenationOperation : BinaryExpression;

// Map expressions
abstract MapOperation : UnaryExpression;

MapAccessOperation : MapOperation ::= Indexes:Expression*;

MapRangedAccessOperation : MapOperation ::= <RangeStart:NumberLiteral> <RangeEnd:NumberLiteral>;

MapUpdateOperation : MapAccessOperation ::= Update:Expression;

// Quantifier expressions
abstract QuantifierExpression : UnaryExpression ::= TypeArguments:TypeVariable* Parameters:QuantifierBinding* Triggers:Expression*;

QuantifierBinding : Binding;

UniversalQuantifier : QuantifierExpression;

ExistentialQuantifier : QuantifierExpression;

// Symbolic reference
SymbolicReference : Expression ::= Accessor:SymbolicAccessor;

FunctionCall : Expression ::= Accessor:FunctionAccessor Arguments:Expression*;

// Literal expressions
abstract Literal : Expression ::= <Value:String>;

NumberLiteral : Literal;

BitvectorLiteral : Literal;

StringLiteral : Literal;

BooleanLiteral : Literal;

RealLiteral : Literal;

// Statements
abstract Statement ::= [Label];

AssertStatement : Statement ::= Expression;

AssumeStatement : Statement ::= Expression;

HavocStatement : Statement ::= SymbolicReference*;

AssignmentStatement : Statement ::= Targets:SymbolicReference* Source:Expression*;

abstract CallStatement : Statement ::= Accessor:ProcedureAccessor;

TargetedCallStatement : CallStatement ::= Targets:SymbolicReference* Arguments:Expression*;

UniversalCallStatement : CallStatement ::= Arguments:Meta*;

IfStatement : Statement ::= Condition:Meta Then:BlockStatement [Else:BlockStatement];

WhileStatement : Statement ::= Condition:Meta Statement;

BreakStatement : Statement ::= [Label];

ReturnStatement : Statement;

BlockStatement : Statement ::= Statement*;

GotoStatement : Statement ::= Label;

Label ::= <Target:String>;

// Specifications
abstract Specification ::= <Free:Boolean>;

PreCondition ::= Expression;

PostCondition ::= Expression;

FrameCondition ::= SymbolicReference*;

LoopInvariant ::= Expression;
