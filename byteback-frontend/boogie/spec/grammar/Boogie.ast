// A Boogie program is a set of declarations 
Program ::= Declaration*;

// Use accessor whenever a symbol is accessed, and use declarator
// whenever a new symbol is declared.
Accessor ::= <Name:String>;

Declarator ::= <Name:String>;

// Declaration
abstract Declaration ::= Attributes:Attribute*;

abstract Option;

Attribute : Option ::= <Name:String> Arguments:Expression*;

Trigger : Option ::= Expressions:Expression*;

// Binding
abstract Binding ::= Type:Type;

SymbolicBinding : Binding ::= Declarator:Declarator;

OptionalBinding : Binding ::= [Declarator:Declarator];

MultiBinding : Binding ::= Declarators:Declarator*;

BoundedBinding : MultiBinding ::= [WhereClause:WhereClause];

WhereClause ::= Expression:Expression;

// Type
abstract Type;

BoolType : Type;

IntegerType : Type;

RealType : Type;

BitvectorType : Type ::= <Size:String>;

UnknownType : Type ::= Name:Accessor TypeParameters:Type*;

MapType : Type ::= TypeArguments:Declarator* KeyTypes:Type* ValueType:Type;

// Type declaration
abstract TypeDeclaration : Declaration ::= Declarator:Declarator VariableDeclarators:Declarator*;

TypeConstructor : TypeDeclaration ::= <Finite:Boolean>;

TypeSynonym : TypeDeclaration ::= Aliased:Type;

// Axiom declaration
AxiomDeclaration : Declaration ::= Expression:Expression;

// Function declaration
FunctionDeclaration : Declaration ::= Declarator:Declarator Signature:FunctionSignature [Expression:Expression];

FunctionSignature ::= TypeArguments:Declarator* Arguments:Binding* ReturnArgument:Binding;

// Constant declaration
ConstantDeclaration : Declaration ::= Binding:MultiBinding <Unique:Boolean> OrderSpecification:OrderSpecification;

OrderSpecification ::= ParentEdges:ParentEdge* <Complete:Boolean>;

ParentEdge ::= ParentConstant:Accessor <Unique:Boolean> ;

// Variable declaration
VariableDeclaration : Declaration ::= Binding:BoundedBinding*;

// Procedure declaration
ProcedureDeclaration : Declaration ::= Declarator:Declarator Signature:ProcedureSignature Conditions:Specification* [Body];

ProcedureSignature ::= TypeArguments:Declarator* InputParameters:BoundedBinding* OutputParameters:Binding*;

// Implementation declaration
ImplementationDeclaration : Declaration ::= Declarator:Declarator Signature:ImplementationSignature Bodies:Body*;

ImplementationSignature ::= TypeArguments:Declarator* InputParameters:MultiBinding* OutParameters:MultiBinding*;

Body ::= LocalVariables:VariableDeclaration* Statements:Statement*;

// Expressions
abstract Meta;

Star : Meta;

abstract Expression : Meta;

abstract BinaryExpression : Expression ::= LeftOperand:Expression RightOperand:Expression;

abstract UnaryExpression: Expression ::= Operand:Expression;

// Boolean expressions
EquivalenceOperation : BinaryExpression;

ImplicationOperation : BinaryExpression;

OrOperation : BinaryExpression;

AndOperation : BinaryExpression;

NegationOperation : UnaryExpression;

// Relational expressions
EqualsOperation : BinaryExpression;

NotEqualsOperation : BinaryExpression;

LessThanOperation : BinaryExpression;

GreaterThanOperation : BinaryExpression;

LessThanEqualsOperation : BinaryExpression;

GreaterThanEqualsOperation : BinaryExpression;

PartialOrderOperation : BinaryExpression;

// Arithmetic expressions
AdditionOperation : BinaryExpression;

SubtractionOperation : BinaryExpression;

MultiplicationOperation : BinaryExpression;

DivisionOperation : BinaryExpression;

ModuloOperation : BinaryExpression;

MinusOperation : UnaryExpression;

// Bitvector expressions
ConcatenationOperation : BinaryExpression;

// Map expressions
abstract MapOperation : UnaryExpression;

MapAccessOperation : MapOperation ::= Select:MapSelect;

MapRangedAccessOperation : MapOperation ::= <RangeStart:NumberLiteral> <RangeEnd:NumberLiteral>;

MapUpdateOperation : MapAccessOperation ::= Update:Expression;

MapSelect ::= Expressions:Expression*;

// Symbolic reference
abstract SymbolicReference : Expression ::= Accessor:Accessor;

ValueReference : SymbolicReference;

FunctionReference : SymbolicReference ::= Arguments:Expression*;

// Old reference
OldReference : Expression ::= Argument:Expression;

// Quantifier expressions
QuantifierExpression : UnaryExpression ::= Quantifier:Quantifier TypeArguments:Declarator* Parameters:MultiBinding* Options:Option*;

abstract Quantifier;

UniversalQuantifier : Quantifier;

ExistentialQuantifier : Quantifier;

// Literal expressions
abstract Literal : Expression ::= <Value:String>;

NumberLiteral : Literal;

BitvectorLiteral : Literal;

StringLiteral : Literal;

BooleanLiteral : Literal;

RealLiteral : Literal;

// Statements
abstract Statement;

AssertStatement : Statement ::= Expression:Expression;

AssumeStatement : Statement ::= Expression:Expression;

HavocStatement : Statement ::= References:SymbolicReference*;

AssignmentStatement : Statement ::= Targets:Assignee* Source:Expression*;

Assignee ::= Reference:ValueReference;

MapAssignee : Assignee ::= MapSelect;

abstract CallStatement : Statement ::= Accessor:Accessor;

TargetedCallStatement : CallStatement ::= Targets:SymbolicReference* Arguments:Expression*;

UniversalCallStatement : CallStatement ::= Arguments:Meta*;

IfStatement : Statement ::= Condition:Meta Then:BlockStatement [Else:BlockStatement];

WhileStatement : Statement ::= Condition:Meta Statement Invariants:LoopInvariant*;

BreakStatement : Statement ::= [Target:Label];

ReturnStatement : Statement;

BlockStatement : Statement ::= Statement*;

GotoStatement : Statement ::= Label;

LabelStatement : Statement ::= Label;

Label ::= <Target:String>;

// Specifications
abstract Specification ::= <Free:Boolean>;

PreCondition : Specification ::= Expression;

PostCondition : Specification ::= Expression;

FrameCondition : Specification ::= Accessor*;

LoopInvariant : Specification ::= Expression;
