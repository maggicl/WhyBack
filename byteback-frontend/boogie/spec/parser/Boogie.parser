%header {:
    package byteback.frontend.boogie.parser;
    import byteback.frontend.boogie.ast.*;
:};

%goal program;

Program program
    = declaration_list.dl?
    {: return new Program(dl); :}
    ;

List declaration_list
    = declaration.d
    {: return new List(d); :}
    | declaration_list.dl declaration.d
    {: return dl.add(d); :}
    ;

Declaration declaration
    = type_declaration
    ;

List attribute_list
    = attribute.a
    {: return new List(a); :}
    | attribute_list.al attribute.a
    {: return al.add(a); :}
    ;

Attribute attribute
    = LBRACE ID.i expression_comma_separated_list.el? RBRACE
    {: return new Attribute(i, el); :}
    ;

TypeDeclaration type_declaration
    = TYPE attribute_list.al? type_definition.td SEMICOLON
    {:
       td.setAttributesList(al);
       return td;
    :}
    ;

TypeDeclaration type_definition
    = type_constructor_definition
    | finite_type_constructor_definition
    | type_synonym_definition
    ;

TypeConstructor finite_type_constructor_definition
    = FINITE type_constructor_definition.tcd
    {:
       tcd.setFinite(true);
       return tcd;
    :}
    ;

TypeConstructor type_constructor_definition
    = type_declarator.td type_variable_list.tal?
    {: return new TypeConstructor(new List(), td, tal, false); :}
    ;

TypeSynonym type_synonym_definition
    = type_declarator.td type_variable_list.tal EQUALS type_accessor.tac
    {: return new TypeSynonym(new List(), td, tal, tac); :}
    ;

List type_accessor_comma_separated_list
    = type_accessor.ta
    {: return new List(ta); :}
    | type_accessor_comma_separated_list.tal COMMA type_accessor.ta
    {: return tal.add(ta); :}
    ;

TypeAccessor type_accessor
    = type.t
    {: return new TypeAccessor(t); :}
    ;

Type type
    = type_atom
    | map_type
    | unknown_type
    ;

Type type_atom
    = BOOL
    {: return new BoolType(); :}
    | INT
    {: return new IntegerType(); :}
    | REAL
    {: return new RealType(); :}
    | LPAREN type RPAREN
    ;

MapType map_type
    = type_variable_block_list.tvl? LBRACKET type_accessor_comma_separated_list.tal RBRACKET type_accessor.ta
    {: return new MapType(tvl, tal, ta); :}
    ;

UnknownType unknown_type
    = ID.tn TODO
    {: return new UnknownType(tn, null); :}
    ;

TypeDeclarator type_declarator
    = ID.tn
    {: return new TypeDeclarator(tn); :}
    ;

List type_variable_block_list
    = LANGLE type_variable_comma_separated_list RANGLE
    ;

List type_variable_list
    = type_variable.tv
    {: return new List(tv); :}
    | type_variable_list.tal type_variable.tv
    {: return tal.add(tv); :}
    ;

List type_variable_comma_separated_list
    = type_variable.tv
    {: return new List(tv); :}
    | type_variable_list.tal COMMA type_variable.tv
    {: return tal.add(tv); :}
    ;

TypeVariable type_variable
    = ID.tvn
    {: return new TypeVariable(tvn); :}
    ;

List expression_comma_separated_list
    = expression.e
    {: return new List(e); :}
    | expression_comma_separated_list.el expression.e
    {: return el.add(e); :}
    ;

Expression expression
    = expression0
    ;

Expression expression0
    = expression1
    | equivalence_operation
    ;

EquivalenceOperation equivalence_operation
    = expression1.lhs IFF expression2.rhs
    {: return new EquivalenceOperation(lhs, rhs); :}
    ;

Expression expression1
    = expression2
    | implication_operation
    ;

ImplicationOperation implication_operation
    = expression2.lhs IMPLIES expression3.rhs
    {: return new ImplicationOperation(lhs, rhs); :}
    ;

Expression expression2
    = expression3
    | or_operation
    | and_operation
    ;

OrOperation or_operation
    = expression3.lhs OR expression3.rhs
    {: return new OrOperation(lhs, rhs); :}
    ;

AndOperation and_operation
    = expression3.lhs AND expression3.rhs
    {: return new AndOperation(lhs, rhs); :}
    ;

Expression expression3
    = LITERAL
    ;