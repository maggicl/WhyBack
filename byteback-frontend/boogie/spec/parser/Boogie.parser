%header {:
    package byteback.frontend.boogie.parser;
    import byteback.frontend.boogie.ast.*;
:};

%goal program;

Program program
    = declaration_list.dl?
    {: return new Program(dl); :}
    ;

List declaration_list
    = declaration.d
    {: return new List(d); :}
    | declaration_list.dl declaration.d
    {: return dl.add(d); :}
    ;

Declaration declaration
    = type_declaration
    ;

List attribute_list
    = attribute.a
    {: return new List(a); :}
    | attribute_list.al attribute.a
    {: return al.add(a); :}
    ;

Attribute attribute
    = LBRACE ID.i expression_comma_separated_list.el? RBRACE
    {: return new Attribute(i, el); :}
    ;

TypeDeclaration type_declaration
    = TYPE attribute_list.al? type_definition.td SEMICOLON
    {:
       td.setAttributesList(al);
       return td;
    :}
    ;

TypeDeclaration type_definition
    = type_constructor_definition
    | finite_type_constructor_definition
    | type_synonym_definition
    ;

TypeConstructor finite_type_constructor_definition
    = FINITE type_constructor_definition.tcd
    {:
       tcd.setFinite(true);
       return tcd;
    :}
    ;

TypeConstructor type_constructor_definition
    = type_declarator.td type_variable_list.tal?
    {: return new TypeConstructor(new List(), td, tal, false); :}
    ;

TypeSynonym type_synonym_definition
    = type_declarator.td type_variable_list.tal EQUALS type_accessor.tac
    {: return new TypeSynonym(new List(), td, tal, tac); :}
    ;

List type_accessor_comma_separated_list
    = type_accessor.ta
    {: return new List(ta); :}
    | type_accessor_comma_separated_list.tal COMMA type_accessor.ta
    {: return tal.add(ta); :}
    ;

List type_accessor_constructor_list
    = type_atom_accessor.ta type_accessor_constructor_list.tal
    {: return tal.add(ta); :}
    | type_accessor.ta
    {: return new List(ta); :}
    ;

TypeAccessor type_accessor
    = type_atom_accessor
    | map_type_accessor
    | unknown_type_accessor
    ;

TypeAccessor type_atom_accessor
    = type_atom.t
    {: return new TypeAccessor(t); :}
    ;

TypeAccessor map_type_accessor
    = map_type.t
    {: return new TypeAccessor(t); :}
    ;

TypeAccessor unknown_type_accessor
    = unknown_type.t
    {: return new TypeAccessor(t); :}
    ;

Type type
    = type_atom
    | map_type
    | unknown_type
    ;

Type type_atom
    = BOOL
    {: return new BoolType(); :}
    | INT
    {: return new IntegerType(); :}
    | REAL
    {: return new RealType(); :}
    | LPAREN type RPAREN
    ;

MapType map_type
    = type_variable_block_list.tvl? LBRACKET type_accessor_comma_separated_list.tal RBRACKET type_accessor.ta
    {: return new MapType(tvl, tal, ta); :}
    ;

UnknownType unknown_type
    = ID.tn type_accessor_constructor_list.tal
    {: return new UnknownType(tn, tal); :}
    ;

TypeDeclarator type_declarator
    = ID.tn
    {: return new TypeDeclarator(tn); :}
    ;

List type_variable_block_list
    = LANGLE type_variable_comma_separated_list RANGLE
    ;

List type_variable_list
    = type_variable.tv
    {: return new List(tv); :}
    | type_variable_list.tal type_variable.tv
    {: return tal.add(tv); :}
    ;

List type_variable_comma_separated_list
    = type_variable.tv
    {: return new List(tv); :}
    | type_variable_list.tal COMMA type_variable.tv
    {: return tal.add(tv); :}
    ;

TypeVariable type_variable
    = ID.tvn
    {: return new TypeVariable(tvn); :}
    ;

List expression_comma_separated_list
    = expression.e
    {: return new List(e); :}
    | expression_comma_separated_list.el expression.e
    {: return el.add(e); :}
    ;

Expression expression
    = expression0
    ;

Expression expression0
    = expression1
    | equivalence_operation
    ;

EquivalenceOperation equivalence_operation
    = expression1.lhs IFF expression0.rhs
    {: return new EquivalenceOperation(lhs, rhs); :}
    ;

Expression expression1
    = expression2
    | implication_operation
    ;

ImplicationOperation implication_operation
    = expression2.lhs IMPLIES expression1.rhs
    {: return new ImplicationOperation(lhs, rhs); :}
    ;

Expression expression2
    = expression3
    | or_operation
    | and_operation
    ;

OrOperation or_operation
    = expression3.lhs OR expression3.rhs
    {: return new OrOperation(lhs, rhs); :}
    ;

AndOperation and_operation
    = expression3.lhs AND expression3.rhs
    {: return new AndOperation(lhs, rhs); :}
    ;

Expression expression3
    = expression4
    | relational_operation
    ;

RelationalOperation relational_operation
    = equals_operation
    | not_equals_operation
    | less_than_operation
    | greater_than_operation
    | less_than_equals_operation
    | greater_than_equals_operation
    | partial_order_operation
    ;

RelationalOperation equals_operation
    = expression4.lhs EQUALS expression4.rhs
    {: return new EqualsOperation(lhs, rhs); :}
    ;

RelationalOperation not_equals_operation
    = expression4.lhs NEQ expression4.rhs
    {: return new NotEqualsOperation(lhs, rhs); :}
    ;

RelationalOperation less_than_operation
    = expression4.lhs LT expression4.rhs
    {: return new LessThanOperation(lhs, rhs); :}
    ;

RelationalOperation greater_than_operation
    = expression4.lhs GT expression4.rhs
    {: return new GreaterThanOperation(lhs, rhs); :}
    ;

RelationalOperation less_than_equals_operation
    = expression4.lhs LTEQ expression4.rhs
    {: return new LessThanEqualsOperation(lhs, rhs); :}
    ;

RelationalOperation greater_than_equals_operation
    = expression4.lhs GTEQ expression4.rhs
    {: return new EqualsOperation(lhs, rhs); :}
    ;

RelationalOperation partial_order_operation
    = expression4.lhs PARTORDER expression4.rhs
    {: return new PartialOrderOperation(lhs, rhs); :}
    ;

Expression expression4
    = expression5
    | concatenation_operation
    ;

ConcatenationOperation concatenation_operation
    = expression4.lhs CONCAT expression5.rhs
    {: return new ConcatenationOperation(lhs, rhs); :}
    ;

Expression expression5
    = expression6
    | addition_operation
    ;

AdditionOperation addition_operation
    = expression5.lhs PLUS expression6.rhs
    {: return new AdditionOperation(lhs, rhs); :}
    ;

Expression expression6
    = expression7
    | multiplication_operation
    ;

MultiplicationOperation multiplication_operation
    = expression6.lhs TIMES expression7.rhs
    {: return new AdditionOperation(lhs, rhs); :}
    ;

Expression expression7
    = TERMINAL;
    ;