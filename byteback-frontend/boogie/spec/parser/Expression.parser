Meta meta
    = expression
    | star
    ;

Star star
    = TIMES
    {: return new Star(); :}
    ;

List meta_comma_list
    = meta.m
    {: return new List(m); :}
    | meta_comma_list.ml COMMA meta.m
    {: return ml.add(m); :}
    ;

Expression expression
    = expression0
    ;

List expression_comma_list
    = expression.e
    {: return new List(e); :}
    | expression_comma_list.el COMMA expression.e
    {: return el.add(e); :}
    ;

Expression expression0
    = expression1
    | equivalence_operation
    ;

EquivalenceOperation equivalence_operation
    = expression1.lhs IFF expression0.rhs
    {: return new EquivalenceOperation(lhs, rhs); :}
    ;

Expression expression1
    = expression2
    | implication_operation
    ;

ImplicationOperation implication_operation
    = expression2.lhs IMPLIES expression1.rhs
    {: return new ImplicationOperation(lhs, rhs); :}
    ;

Expression expression2
    = expression3
    | or_operation
    | and_operation
    ;

OrOperation or_operation
    = expression3.lhs OR expression3.rhs
    {: return new OrOperation(lhs, rhs); :}
    ;

AndOperation and_operation
    = expression3.lhs AND expression3.rhs
    {: return new AndOperation(lhs, rhs); :}
    ;

Expression expression3
    = expression4
    | relational_operation
    ;

RelationalOperation relational_operation
    = equals_operation
    | not_equals_operation
    | less_than_operation
    | greater_than_operation
    | less_than_equals_operation
    | greater_than_equals_operation
    | partial_order_operation
    ;

RelationalOperation equals_operation
    = expression4.lhs EQUALS expression4.rhs
    {: return new EqualsOperation(lhs, rhs); :}
    ;

RelationalOperation not_equals_operation
    = expression4.lhs NEQ expression4.rhs
    {: return new NotEqualsOperation(lhs, rhs); :}
    ;

RelationalOperation less_than_operation
    = expression4.lhs LT expression4.rhs
    {: return new LessThanOperation(lhs, rhs); :}
    ;

RelationalOperation greater_than_operation
    = expression4.lhs GT expression4.rhs
    {: return new GreaterThanOperation(lhs, rhs); :}
    ;

RelationalOperation less_than_equals_operation
    = expression4.lhs LTEQ expression4.rhs
    {: return new LessThanEqualsOperation(lhs, rhs); :}
    ;

RelationalOperation greater_than_equals_operation
    = expression4.lhs GTEQ expression4.rhs
    {: return new EqualsOperation(lhs, rhs); :}
    ;

RelationalOperation partial_order_operation
    = expression4.lhs PARTORDER expression4.rhs
    {: return new PartialOrderOperation(lhs, rhs); :}
    ;

Expression expression4
    = expression5
    | concatenation_operation
    ;

ConcatenationOperation concatenation_operation
    = expression4.lhs CONCAT expression5.rhs
    {: return new ConcatenationOperation(lhs, rhs); :}
    ;

Expression expression5
    = expression6
    | addition_operation
    ;

AdditionOperation addition_operation
    = expression5.lhs PLUS expression6.rhs
    {: return new AdditionOperation(lhs, rhs); :}
    ;

Expression expression6
    = expression7
    | multiplication_operation
    | division_operation
    | modulo_operation
    ;

MultiplicationOperation multiplication_operation
    = expression6.lhs TIMES expression7.rhs
    {: return new MultiplicationOperation(lhs, rhs); :}
    ;

DivisionOperation division_operation
    = expression6.lhs DIVIDE expression7.rhs
    {: return new DivisionOperation(lhs, rhs); :}
    ;

ModuloOperation modulo_operation
    = expression6.lhs MOD expression7.rhs
    {: return new ModuloOperation(lhs, rhs); :}
    ;

Expression expression7
    = expression8
    | unary_expression
    ;

UnaryExpression unary_expression
    = negation_operation
    | minus_operation
    ;

NegationOperation negation_operation
    = NOT expression7.op
    {: return new NegationOperation(op); :}
    ;

MinusOperation minus_operation
    = MINUS expression7.op
    {: return new MinusOperation(op); :}
    ;

Expression expression8
    = expression9
    | map_expression
    ;

MapOperation map_expression
    = expression9.op LBRACKET map_operation.mo RBRACKET
    {:
       mo.setOperand(op);
       return mo;
    :}
    ;

MapOperation map_operation
    = map_access_operation
    | map_ranged_access_operation
    | map_update_operation
    ;

MapAccessOperation map_access_operation
    = expression_comma_list.el
    {: return new MapAccessOperation(null, new MapSelect(el)); :}
    ;

MapAccessOperation map_ranged_access_operation
    = number_literal.a COLON number_literal.b
    {: return new MapRangedAccessOperation(null, a, b); :}
    ;

MapAccessOperation map_update_operation
    = expression_comma_list.el COLONEQ expression.ue
    {: return new MapUpdateOperation(null, new MapSelect(el), ue); :}
    ;

Expression expression9
    = literal
    | symbolic_reference
    | old_reference
    | LPAREN quantifier_expression RPAREN
    | LPAREN expression RPAREN
    ;

QuantifierExpression quantifier_expression
    = universal_quantifier_expression
    | existential_quantifier_expression
    ;

QuantifierExpression universal_quantifier_expression
    = FORALL quantifier_definition.e
    {:
       e.setQuantifier(new UniversalQuantifier());
       return e;
    :}
    ;

QuantifierExpression existential_quantifier_expression
    = EXISTS quantifier_definition.e
    {:
       e.setQuantifier(new ExistentialQuantifier());
       return e;
    :}
    ;

QuantifierExpression quantifier_definition
    = type_variable_block_list.dl? set_binding_comma_list.bl QSEP option_list.ol? expression.e
    {: return new QuantifierExpression(e, null, dl, bl, ol); :}
    ;

SymbolicReference symbolic_reference
    = value_reference
    | function_reference
    ;

ValueReference value_reference
    = accessor.a
    {: return new ValueReference(a); :}
    ;

FunctionReference function_reference
    = accessor.a LPAREN expression_comma_list.el? RPAREN
    {: return new FunctionReference(a, el); :}
    ;

OldReference old_reference
    = OLD LPAREN expression.e RPAREN
    {: return new OldReference(e); :}
    ;

Literal literal
    = boolean_literal 
    | number_literal
    | real_literal
    | bitvector_literal
    ;

BooleanLiteral boolean_literal
    = TRUE.n
    {: return new BooleanLiteral(n); :}
    | FALSE.n
    {: return new BooleanLiteral(n); :}
    ;

NumberLiteral number_literal
    = NUMBER.n
    {: return new NumberLiteral(n); :}
    ;

RealLiteral real_literal
    = REALNUMBER.n
    {: return new RealLiteral(n); :}
    ;

BitvectorLiteral bitvector_literal
    = BITVECTOR.bv
    {: return new BitvectorLiteral(bv); :}
    ;