# -*- Python -*-

import lit.util
import lit.formats
from lit import TestRunner
from lit import Test
import os
import re
import sys
import atexit
import threading
from multiprocessing import Manager
import pandas as pd

# Do not return an error code for UNRESOLVED tests
Test.UNRESOLVED.isFailure = False

# Patching the default lit substitution macros
get_default_substitutions = TestRunner.getDefaultSubstitutions


def strip_extension(name):
    return '.'.join(name.split('.')[:-1])


def patch_get_default_substitutions(test, tmpDir, tmpBase, normalize_slashes=False):
    substitutions = get_default_substitutions(test, tmpDir, tmpBase, normalize_slashes)
    source_path = test.getSourcePath()
    extension = source_path.split('.')[-1]

    if any(source_path.endswith(suffix) for suffix in config.suffixes):
        qualified_name = strip_extension(source_path).split(os.sep)[8:]
        qualified_path = qualified_name[:-1]
        substitutions.append(('%{class}', '.'.join(qualified_name)))

    return substitutions


TestRunner.getDefaultSubstitutions = patch_get_default_substitutions


manager = Manager()
summary = manager.list()
summary_lock = threading.Lock()
summary_path = "./summary.csv"

run_sh_test = TestRunner._runShTest


def sanitize_command(string):
    pattern = r"%dbg\(.*\)"
    stripped_string = string.strip()
    match = re.match(pattern, stripped_string)
    
    if match:
        return stripped_string[len(match.group(0)) :].strip()
    else:
        return stripped_string


def extract_commands(script):
    return [sanitize_command(command) for subcommands in script for command in subcommands.split("|")]


def is_boogie_command(command):
    return command.startswith("boogie")


def is_byteback_command(command):
    return command.startswith(byteback_executable)


src_base = os.getenv('SRC_BASE')
build_base = os.getenv('CLASS_BASE')


def get_file_extension(path):
    _, ext = os.path.splitext(path)

    return ext


def patch_run_sh_test(test, litConfig, useExternalSh, script, tmpBase):
    entry = {}

    for command in extract_commands(script):
        if is_byteback_command(command):
            entry["BytebackCommand"] = command
        elif is_boogie_command(command):
            entry["BoogieCommand"] = command

    test_path = test.getFilePath()
    test_ext = get_file_extension(test_path)
    test_name = os.path.basename(test_path)
    deps_base = os.path.dirname(test_path)
    deps_path = test_path + ".deps"
    deps = [test_path]

    if os.path.exists(deps_path):
        with open(deps_path, "r") as deps_file:
            deps.extend(deps_file.readlines())

    entry["Source"] = deps

    classes = []

    for dep in deps:
        classes.append(build_base + "/" + test_path.removeprefix(src_base).removesuffix(test_ext) + ".class")

    entry["Class"] = classes
    summary.append(entry)

    entry["Boogie"] = deps_base + "/Output/" + test_name + ".tmp.bpl"
    return run_sh_test(test, litConfig, useExternalSh, script, tmpBase)


TestRunner._runShTest = patch_run_sh_test


def print_summary(*args):
    df = pd.DataFrame(list(summary))
    df.to_csv("./summary.csv")


atexit.register(print_summary)


byteback_executable = os.getenv('BYTEBACK_ROOT') + "/bin/byteback-cli"
test_jar = os.getenv('TEST_JAR')

# Tests configuration
lit_config.note('using Python {}'.format(sys.version))

config.name = 'ByteBack'
config.test_format = lit.formats.ShTest(execute_external=False)
config.suffixes = ['.java', '.scala', '.groovy', '.kt']
config.substitutions.append(("%{byteback}", byteback_executable))
config.substitutions.append(("%{jar}", test_jar))
config.substitutions.append(("%{byteback-all}", "%{byteback} -cp %{jar}"))
config.substitutions.append(("%{byteback-current}", "%{byteback-all} -c %{class}"))
config.substitutions.append(("%{byteback-convert}", "%{byteback-current} -o %s.actual.bpl"))
config.substitutions.append(("%{check-actual}", "diff %s.actual.bpl %s.expect.bpl"))
config.substitutions.append(("%{verify}", "boogie /timeLimit:20"))

if 'JAVA_HOME' in os.environ:
    config.environment['JAVA_HOME'] = os.environ['JAVA_HOME']
