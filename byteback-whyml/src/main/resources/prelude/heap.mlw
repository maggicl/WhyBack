module Primitive
  use prelude.ptr.Ptr
  use prelude.typing.Type

  type value

  type static_field = abstract { }
  type instance_field = abstract { }

  type t = {
    (* Static fields have only one value per field declaration, as they are static *)
    mutable static_fmap: static_field -> value;
    mutable instance_fmap: (Ptr.t, instance_field) -> value;
  }

  predicate other_same_static (heap: t) (old_heap: t) (f: static_field) =
    forall f'. f <> f' ->
      heap.static_fmap f' = old_heap.static_fmap f'

  predicate other_same_instance (heap: t) (old_heap: t) (p: Ptr.t) (f: instance_field) =
    forall p',f'. (p <> p' || f <> f') ->
      heap.instance_fmap (p',f') = old_heap.instance_fmap (p',f')

  val function isf (heap: t) (p: Ptr.t) (f: instance_field) : value
    requires { p <> Ptr.null }
    ensures { result = heap.instance_fmap (p, f) }

  val getf (heap: t) (p: Ptr.t) (f: instance_field) : value
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> result = isf heap p f }

  val putf (heap: t) (p: Ptr.t) (f: instance_field) (v: value) : unit
    writes { heap.instance_fmap }
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> heap.instance_fmap (p, f) = v }
    ensures { other_same_instance heap (old heap) p f }

  let function iss [@inline:trivial] (heap: t) (f: static_field) : value =
    heap.static_fmap f

  let function gets [@inline:trivial] (heap: t) (f: static_field) : value =
    iss heap f

  val puts (heap: t) (f: static_field) (c: value) : unit
    writes { heap.static_fmap }
    ensures { heap.static_fmap f = c }
    ensures { other_same_static heap (old heap) f }
end

module Z
  use export prelude.boolean.Operators
  clone export Primitive with type value = jbool
end

module B
  use export prelude.machine.Operators
  clone export Primitive with type value = jbyte
end

module S
  use export prelude.machine.Operators
  clone export Primitive with type value = jshort
end

module C
  use export prelude.machine.Operators
  clone export Primitive with type value = jchar
end

module I
  use export prelude.machine.Operators
  clone export Primitive with type value = jint
end

module J
  use export prelude.machine.Operators
  clone export Primitive with type value = jlong
end

module F
  use export prelude.machine.Operators
  clone export Primitive with type value = jfloat
end

module D
  use export prelude.machine.Operators
  clone export Primitive with type value = jdouble
end

module L
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use set.Set

  type static_field = abstract { s_type: Type.t; }
  type instance_field = abstract { i_type: Type.t; }

  type t = {
    mutable pointers: set Ptr.t;
    typeof: Ptr.t -> Type.t;
    mutable static_fmap: static_field -> Ptr.t;
    mutable instance_fmap: (Ptr.t, instance_field) -> Ptr.t;
  } invariant {
    (not (mem Ptr.null pointers)) &&
    (forall s:static_field. static_fmap s = Ptr.null \/ typeof (static_fmap s) :> s.s_type) &&
    (forall p:Ptr.t, s:instance_field. compatible (instance_fmap (p,s)) typeof s.i_type)
  }

  predicate other_same_static (heap: t) (old_heap: t) (f: static_field) =
    forall f'. f <> f' ->
      heap.static_fmap f' = old_heap.static_fmap f'

  predicate other_same_instance (heap: t) (old_heap: t) (p: Ptr.t) (f: instance_field) =
    forall p',f'. p <> p' || f <> f' ->
      heap.instance_fmap (p',f') = old_heap.instance_fmap (p',f')

  val function isf (heap: t) (p: Ptr.t) (f: instance_field) : Ptr.t
    requires { p <> Ptr.null }
    ensures { result = heap.instance_fmap (p,f) }
    ensures { compatible result heap.typeof f.i_type }

  val getf (heap: t) (p: Ptr.t) (f: instance_field) : Ptr.t
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> result = isf heap p f }
    ensures { p <> Ptr.null -> compatible result heap.typeof f.i_type }

  val putf (heap: t) (p: Ptr.t) (f: instance_field) (v: Ptr.t) : unit
    writes { heap.instance_fmap }
    requires { compatible v heap.typeof f.i_type }
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> heap.instance_fmap (p,f) = v }
    ensures { other_same_instance heap (old heap) p f }

  val function iss (heap: t) (f: static_field) : Ptr.t
    ensures { result = heap.static_fmap f }
    ensures { compatible result heap.typeof f.s_type }

  let function gets [@inline:trivial] (heap: t) (f: static_field) : Ptr.t =
    iss heap f

  val puts (heap: t) (f: static_field) (v: Ptr.t) : unit
    writes { heap.static_fmap }
    requires { compatible v heap.typeof f.s_type }
    ensures { heap.static_fmap f = v }
    ensures { other_same_static heap (old heap) f }

  predicate is_new_ptr (result: Ptr.t) (of_type: Type.t) (heap: t) (old_heap: t) =
    result <> Ptr.null /\
    mem result heap.pointers /\
    not (mem result old_heap.pointers) /\
    heap.typeof result = of_type
end

module PrimitiveArray
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use prelude.machine.Operators
  use array.Array
  use int.Int
  use set.Set

  type elem
  val function default_value : elem

  type t = {
    mutable arrays: set Ptr.t;
    mutable elements: Ptr.t -> {array elem}
  }

  predicate other_same_array (heap: t) (old_heap: t) (p: Ptr.t) =
    forall p'. p <> p' ->
      (heap.elements p).elts = (old_heap.elements p').elts

  predicate valid_access (heap: t) (p: Ptr.t) (i: jint) =
    mem p heap.arrays && 0 <= i < (heap.elements p).length

  val function iselem (heap: t) (p: Ptr.t) (i: jint) : elem
    requires { valid_access heap p i }
    ensures { result = (heap.elements p)[i] }

  val load (heap: t) (p: Ptr.t) (i: jint) : elem
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { valid_access heap p i -> result = iselem heap p i }

  val store (heap: t) (p: Ptr.t) (i: jint) (v: elem) : unit
    writes { heap.elements }
    ensures { valid_access heap p i -> (heap.elements p).elts = Map.set (old (heap.elements p)).elts i v }
    ensures { valid_access heap p i -> (heap.elements p) = (old (heap.elements p)[i <- v]) }
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { other_same_array heap (old heap) p }

  val function arraylength (heap: t) (p: Ptr.t) : jint
    requires { mem p heap.arrays }
    ensures { result = int2i (heap.elements p).length }

  predicate is_new_array (result: Ptr.t) (len: int) (heap: t) (old_heap: t) =
    result <> Ptr.null /\
    mem result heap.arrays /\
    not (mem result old_heap.arrays) /\
    (heap.elements result).length = len /\
    forall i:int. 0 <= i < len -> (heap.elements result)[i] = default_value
end

module RZ
  use prelude.boolean.Operators
  clone export PrimitiveArray with type elem = jbool, val default_value = Default.z
end

module RB
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jbyte, val default_value = Default.b
end

module RS
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jshort, val default_value = Default.s
end

module RC
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jchar, val default_value = Default.c
end

module RI
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jint, val default_value = Default.i
end

module RJ
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jlong, val default_value = Default.j
end

module RF
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jfloat, val default_value = Default.f
end

module RD
  use prelude.machine.Operators
  clone export PrimitiveArray with type elem = jdouble, val default_value = Default.d
end

module Heap
  use int.Int
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use prelude.ptr.Operators
  use array.Array
  use int.Int
  use set.Set
  use Z
  use B
  use S
  use C
  use I
  use J
  use F
  use D
  use L
  use RZ
  use RB
  use RS
  use RC
  use RI
  use RJ
  use RF
  use RD

  type t = {
    z: Z.t;
    b: B.t;
    s: S.t;
    c: C.t;
    i: I.t;
    j: J.t;
    f: F.t;
    d: D.t;
    l: L.t;
    rz: RZ.t;
    rb: RB.t;
    rs: RS.t;
    rc: RC.t;
    ri: RI.t;
    rj: RJ.t;
    rf: RF.t;
    rd: RD.t;
    mutable rl_arrays: set Ptr.t;
    rl_element_type: Ptr.t -> Type.t;
    mutable rl_elements: Ptr.t -> {array Ptr.t};
  } invariant {
     (not (mem Ptr.null rl_arrays)) &&
     (forall e:Ptr.t, i:int. (mem e rl_arrays && (0 <= i < (rl_elements e).length)) ->
       compatible (rl_elements e)[i] l.typeof (rl_element_type e))
  }

  type ht = t

  use L

  let predicate instanceof [@inline:trivial] (heap: ht) (p: Ptr.t) (t: Type.t) =
    not_null p && compatible p heap.l.typeof t

  val checkcast (heap: ht) (p: Ptr.t) (t: Type.t) : Ptr.t
    ensures { compatible p heap.l.typeof t -> result = p }
    (* raises { JException e -> not (hastype heap p t) && e = Java.Lang.ClassCastException.class } *)

  val function iscast (heap: ht) (p: Ptr.t) (t: Type.t) : Ptr.t
    requires { compatible p heap.l.typeof t }
    ensures { result = p }

  val new (heap: ht) (id: Type.class) : Ptr.t
    writes { heap.l.pointers }
    ensures { L.is_new_ptr result (Type.Class id) heap.l (old heap.l) }

  (* TODO: when re-introducing PEI behaviour, here is the place for NegativeArraySize and ArrayStore *)

  use RZ
  val znewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rz.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.BoolArray heap.l (old heap.l) }
    ensures { len >= 0 -> RZ.is_new_array result len heap.rz (old heap.rz) }

  use RB
  val bnewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rb.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.ByteArray heap.l (old heap.l) }
    ensures { len >= 0 -> RB.is_new_array result len heap.rb (old heap.rb) }

  use RS
  val snewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rs.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.ShortArray heap.l (old heap.l) }
    ensures { len >= 0 -> RS.is_new_array result len heap.rs (old heap.rs) }

  use RC
  val cnewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rc.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.CharArray heap.l (old heap.l) }
    ensures { len >= 0 -> RC.is_new_array result len heap.rc (old heap.rc) }

  use RI
  val inewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.ri.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.IntArray heap.l (old heap.l) }
    ensures { len >= 0 -> RI.is_new_array result len heap.ri (old heap.ri) }

  use RJ
  val jnewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rj.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.LongArray heap.l (old heap.l) }
    ensures { len >= 0 -> RJ.is_new_array result len heap.rj (old heap.rj) }

  use RF
  val fnewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rf.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.FloatArray heap.l (old heap.l) }
    ensures { len >= 0 -> RF.is_new_array result len heap.rf (old heap.rf) }

  use RD
  val dnewarray (heap: ht) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rd.arrays }
    ensures { len >= 0 -> L.is_new_ptr result Type.DoubleArray heap.l (old heap.l) }
    ensures { len >= 0 -> RD.is_new_array result len heap.rd (old heap.rd) }

  scope RL
    predicate other_same_array (heap: ht) (old_heap: ht) (p: Ptr.t) =
      forall p'. p <> p' ->
        (heap.rl_elements p).elts = (old_heap.rl_elements p').elts

    predicate valid_access (heap: ht) (p: Ptr.t) (i: jint) =
      mem p heap.rl_arrays && 0 <= i < (heap.rl_elements p).length

    val function iselem (heap: ht) (p: Ptr.t) (i: jint) : Ptr.t
      requires { valid_access heap p i }
      ensures { result = (heap.rl_elements p)[i] }

    val load (heap: ht) (p: Ptr.t) (i: jint) : Ptr.t
      (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
      ensures { valid_access heap p i -> result = iselem heap p i }

    val store (heap: ht) (p: Ptr.t) (i: jint) (v: Ptr.t) : unit
      writes { heap.rl_elements }
      ensures { valid_access heap p i -> (heap.rl_elements p).elts = Map.set (old (heap.rl_elements p)).elts i v }
      ensures { valid_access heap p i -> (heap.rl_elements p) = (old (heap.rl_elements p))[i <- v] }
      (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
      ensures { other_same_array heap (old heap) p }

    val function arraylength (heap: ht) (p: Ptr.t) : jint
      requires { mem p heap.rl_arrays }
      ensures { result = int2i (heap.rl_elements p).length }

    predicate is_new_array (result: Ptr.t) (len: int) (of_elem_type: Type.t) (heap: ht) (old_heap: ht) =
      result <> Ptr.null /\
      mem result heap.rl_arrays /\
      not (mem result old_heap.rl_arrays) /\
      heap.rl_element_type result = of_elem_type /\
      (heap.rl_elements result).length = len /\
      forall i:int. 0 <= i < len -> (heap.rl_elements result)[i] = Ptr.null
  end

  val lnewarray (heap: ht) (elem_type: Type.t) (len: jint) : Ptr.t
    writes { heap.l.pointers, heap.rl_arrays }
    ensures { len >= 0 -> L.is_new_ptr result (ArrayOf elem_type) heap.l (old heap.l) }
    ensures { len >= 0 -> RL.is_new_array result len elem_type heap (old heap) }
end
