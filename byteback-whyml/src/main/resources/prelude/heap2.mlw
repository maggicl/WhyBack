module Primitive
  use prelude.ptr.Ptr
  use prelude.typing.Type

  type value

  type static_field = abstract { }
  type instance_field = abstract { }

  type t = {
    (* Static fields have only one value per field declaration, as they are static *)
    mutable static_fmap: static_field -> value;
    mutable instance_fmap: (Ptr.t, instance_field) -> value;
  }

  predicate other_same_static (heap: t) (old_heap: t) (f: static_field) =
    forall f'. f <> f' ->
      heap.static_fmap f' = old_heap.static_fmap f'

  predicate other_same_instance (heap: t) (old_heap: t) (p: Ptr.t) (f: instance_field) =
    forall p',f'. (p <> p' || f <> f') ->
      heap.instance_fmap (p',f') = old_heap.instance_fmap (p',f')

  val function isf (heap: t) (p: Ptr.t) (f: instance_field) : value
    requires { p <> Ptr.null }
    ensures { result = heap.instance_fmap (p, f) }

  val getf (heap: t) (p: Ptr.t) (f: instance_field) : value
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> result = isf heap p f }

  val putf (heap: t) (p: Ptr.t) (f: instance_field) (v: value) : unit
    writes { heap.instance_fmap }
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> heap.instance_map (p, f) = v }
    ensures { other_same_instance heap (old heap) p f }

  val function iss (heap: t) (f: static_field) =
    ensures { result = heap.static_fmap f }

  let function gets [@inline:trivial] (heap: t) (f: static_field) : value =
    iss heap f

  val puts (heap: t) (f: field) (c: value) : unit
    writes { heap.static_fmap }
    ensures { heap.static_fmap f = c }
    ensures { other_same_static heap (old heap) f }
end

module Z
  use export prelude.boolean.Operators
  clone export Primitive with type value = jbool
end

module B
  use export prelude.machine.Operators
  clone export Primitive with type value = jbyte
end

module S
  use export prelude.machine.Operators
  clone export Primitive with type value = jshort
end

module C
  use export prelude.machine.Operators
  clone export Primitive with type value = jchar
end

module I
  use export prelude.machine.Operators
  clone export Primitive with type value = jint
end

module J
  use export prelude.machine.Operators
  clone export Primitive with type value = jlong
end

module F
  use export prelude.machine.Operators
  clone export Primitive with type value = jfloat
end

module D
  use export prelude.machine.Operators
  clone export Primitive with type value = jdouble
end

module L
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use set.Set

  type static_field = abstract { field_type: Type.t; }
  type instance_field = abstract { field_type: Type.t; }

  type t = {
    mutable pointers: set Ptr.t;
    (* TODO: make sure anewarray ensures the corresponding value here is set to ArrayOf ... *)
    typeof: Ptr.t -> Type.t;
    mutable static_fmap: static_field -> Ptr.t;
    mutable instance_fmap: (Type.class, instance_field) -> Ptr.t;
  } invariant {
    (not (mem Ptr.null pointers)) &&
    (forall s:static_field. static_fmap s = Ptr.null \/ typeof (static_fmap s) :> s.field_type) &&
    (forall p:Ptr.t, s:instance_field. instanceof (instance_fmap (p,s)) typeof s.field_type)
  }

  predicate other_same_static (heap: t) (old_heap: t) (f: static_field ) =
    forall f'. f <> f' ->
      heap.static_fmap f' = old_heap.static_fmap f'

  predicate other_same_instance (heap: t) (old_heap: t) (p: Ptr.t) (f: ptrfield) =
    forall p',f'. p <> p' || f <> f' ->
      heap.instance_fmap (p',f') = old_heap.instance_fmap (p',f')

  val function isf (heap: t) (p: Ptr.t) (f: instance_field) : Ptr.t
    requires { p <> Ptr.null }
    ensures { result = heap.instance_fmap (p,f) }
    ensures { instanceof result heap.typeof f.field_type }

  val getf (heap: t) (p: Ptr.t) (f: instance_field) : Ptr.t
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> result = isf heap p f }
    ensures { p <> Ptr.null -> instanceof result heap.typeof f.field_type }

  val putf (heap: t) (p: Ptr.t) (f: instance_field) (v: Ptr.t) : unit
    writes { heap.instance_fmap }
    requires { instanceof v heap.typeof f.field_type }
    (* raises { JException e -> npe_if_null e p } *)
    ensures { p <> Ptr.null -> heap.instance_fmap (p,f) = v }
    ensures { other_same_instance heap (old heap) p f }

  val function iss (heap: t) (f: static_field) : Ptr.t
    ensures { result = heap.static_fmap f }
    ensures { instanceof result heap.typeof f.field_type }

  let function gets [@inline:trivial] (heap: t) (f: static_field) : Ptr.t =
    iss heap f

  val puts (heap: t) (f: static_field) (v: Ptr.t) : unit
    writes { heap.static_fmap }
    requires { instanceof v heap.typeof f.field_type }
    ensures { heap.static_fmap f = v }
    ensures { other_same_static heap (old heap) f }

  predicate is_new_ptr (result: Ptr.t) (of_type: Type.t) (heap: t) (old_heap: t) =
    result <> Ptr.null /\
    mem result heap.z.pointers /\
    not (mem result old_heap.z.pointers) /\
    heap.z.typeof[result] = of_type
end

module PrimitiveArray
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use array.Array
  use prelude.machine.Operators
  use int.Int

  type elem
  val function default_value : elem

  type t = {
    mutable arrays: set Ptr.t;
    elements: Ptr.t -> array elem
  }

  predicate other_same_array (heap: t) (old_heap: t) (p: Ptr.t) =
    forall p'. p <> p' ->
      heap.elements[p].elts = heap.elements[p'].elts

  predicate valid_access (heap: t) (p: Ptr.t) (i: jint) =
    mem p heap.arrays && 0 <= i < (heap.elements p).length

  val function iselem (heap: t) (p: Ptr.t) (i: jint) : elem
    requires { valid_access heap p i }
    ensures { result = (heap.elements p)[i] }

  val load (heap: t) (p: Ptr.t) (i: jint) : elem
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { valid_access heap p i -> result = iselem heap p i }

  val store (heap: t) (p: Ptr.t) (i: jint) (v: elem) : unit
    writes { heap.elements p }
    ensures { valid_access heap p i -> (heap.elements p).elts = Map.set (old (heap.elements p)).elts i v }
    ensures { valid_access heap p i -> (heap.elements p) = (old (heap.elements p))[i <- v] }``
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { other_same_array heap (old heap) p }

  val function arraylength (heap: t) (p: Ptr.t) : jint
    requires { mem p heap.arrays }
    ensures { result = int2i (heap.elements p).length }

  predicate is_new_array (result: Ptr.t) (len: int) (heap: t) (old_heap: t) =
    result <> Ptr.null /\
    mem result heap.arrays /\
    not (mem result old_heap.arrays) /\
    (heap.elements result).length = len /\
    forall i:int. 0 <= i < len -> (heap.elements result)[i] = default_value
end

module RZ
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jbool, val default_value = Default.z
end

module RB
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jbyte, val default_value = Default.b
end

module RS
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jshort, val default_value = Default.s
end

module RC
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jchar, val default_value = Default.c
end

module RI
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jint, val default_value = Default.i
end

module RJ
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jlong, val default_value = Default.j
end

module RF
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jfloat, val default_value = Default.f
end

module RD
  use primitive.machine.Operators
  clone export PrimitiveArray with type elem = jdouble, val default_value = Default.d
end

module RL
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use prelude.machine.Operators
  use int.Int

  type t = {
    mutable arrays: set Ptr.t;
    element_type: Ptr.t -> Type.t;
    elements: Ptr.t -> array Ptr.t
  } invariant {
    (not (mem Ptr.null arrays)) &&
    (forall e:Ptr.t, i:int. (mem e arrays && (0 <= i < (elements e).length)) ->
      instanceof (elements e) (element_type e))
  }

  predicate valid_access (heap: t) (p: Ptr.t) (i: jint) =
    mem p heap.arrays && 0 <= i < (heap.elements p).length

  val function iselem (heap: t) (p: Ptr.t) (i: jint) : elem
    requires { valid_access heap p i }
    ensures { result = (heap.elements p)[i] }

  val load (heap: t) (p: Ptr.t) (i: jint) : elem
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { valid_access heap p i -> result = iselem heap p i }

  val store (heap: t) (p: Ptr.t) (i: jint) (v: elem) : unit
    writes { heap.elements p }
    ensures { valid_access heap p i -> (heap.elements p).elts = Map.set (old (heap.elements p)).elts i v }
    ensures { valid_access heap p i -> (heap.elements p) = (old (heap.elements p))[i <- v] }``
    (* raises { JException e -> npe_if_null e p || out_of_bounds e heap p i } *)
    ensures { other_same_array heap (old heap) p }

  val function arraylength (heap: t) (p: Ptr.t) : jint
    requires { mem p heap.arrays }
    ensures { result = int2i (heap.elements p).length }

  predicate is_new_array (result: Ptr.t) (len: int) (of_elem_type: Type.t) (heap: t) (old_heap: t) =
    result <> Ptr.null /\
    mem result heap.arrays /\
    not (mem result old_heap.arrays) /\
    heap.element_type result = of_elem_type /\
    (heap.elements result).length = len /\
    forall i:int. 0 <= i < len -> (heap.elements result)[i] = default_value
end

module Heap
  use Z
  use B
  use S
  use C
  use I
  use J
  use F
  use D
  use L
  use RZ
  use RB
  use RS
  use RC
  use RI
  use RJ
  use RF
  use RD
  use RL

  type t = {
    z: Z.t;
    b: B.t;
    s: S.t;
    c: C.t;
    i: I.t;
    j: J.t;
    f: F.t;
    d: D.t;
    l: L.t;
    rz: RZ.t;
    rb: RB.t;
    rs: RS.t;
    rc: RC.t;
    ri: RI.t;
    rj: RL.t;
    rf: RF.t;
    rd: RD.t;
    rl: RL.t;
  }

  val new (heap: t) (id: Type.class) : Ptr.t
    ensures { L.is_new_ptr result (Type.Class id) heap.l (old heap.l) }

  (* TODO: when re-introducing PEI behaviour, here is the place for NegativeArraySize and ArrayStore *)

  val znewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.BoolArray heap.l (old heap.l) }
    ensures { len > 0 -> RZ.is_new_array result len heap.rz (old heap.rz) }

  val bnewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.ByteArray heap.l (old heap.l) }
    ensures { len > 0 -> RB.is_new_array result len heap.rb (old heap.rb) }

  val snewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.ShortArray heap.l (old heap.l) }
    ensures { len > 0 -> RS.is_new_array result len heap.rs (old heap.rs) }

  val cnewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.CharArray heap.l (old heap.l) }
    ensures { len > 0 -> RC.is_new_array result len heap.rc (old heap.rc) }

  val inewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.IntArray heap.l (old heap.l) }
    ensures { len > 0 -> RI.is_new_array result len heap.ri (old heap.ri) }

  val jnewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.LongArray heap.l (old heap.l) }
    ensures { len > 0 -> RJ.is_new_array result len heap.rj (old heap.rj) }

  val fnewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.FloatArray heap.l (old heap.l) }
    ensures { len > 0 -> RF.is_new_array result len heap.rf (old heap.rf) }

  val dnewarray (heap: t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result Type.DoubleArray heap.l (old heap.l) }
    ensures { len > 0 -> RD.is_new_array result len heap.rd (old heap.rd) }

  val lnewarray (heap: t) (elem_type: Type.t) (len: jint)
    ensures { len > 0 -> L.is_new_ptr result (ArrayOf elem_type) heap.l (old heap.l) }
    ensures { len > 0 -> RL.is_new_array result elem_type len heap.rl (old heap.rl) }
end
