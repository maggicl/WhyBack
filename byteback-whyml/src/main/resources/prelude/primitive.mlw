module Int16
  use int.Int

  type int16 = < range -0x8000 0x7fff >

  let constant min_int16 : int = - 0x8000
  let constant max_int16 : int =   0x7fff
  function to_int (x : int16) : int = int16'int x

  clone export mach.int.Bounded_int with
    type t = int16,
    constant min = int16'minInt,
    constant max = int16'maxInt,
    function to_int = int16'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module Int8
  use int.Int

  type int8 = < range -0x80 0x7f >

  let constant min_int8 : int = - 0x80
  let constant max_int8 : int =   0x7f
  function to_int (x : int8) : int = int8'int x

  clone export mach.int.Bounded_int with
    type t = int8,
    constant min = int8'minInt,
    constant max = int8'maxInt,
    function to_int = int8'int,
    lemma to_int_in_bounds,
    lemma extensionality
end

module UInt16Gen
  use int.Int

  type uint16 = < range 0 0xffff >

  let constant max_uint16 : int = 0xffff
  let constant length : int = 16
  let constant radix : int = max_uint16 + 1
  function to_int (x : uint16) : int = uint16'int x
end

module UInt16
  use export UInt16Gen

  clone export mach.int.Unsigned with
    type t = uint16,
    constant max = uint16'maxInt,
    constant radix = radix,
    goal radix_def,
    function to_int = uint16'int,
    lemma zero_unsigned_is_zero,
    lemma to_int_in_bounds,
    lemma extensionality
end

module PrimitiveSupport
    use ieee_float.Float32
    use ieee_float.Float64
    use ieee_float.FloatConverter
    use ieee_float.RoundingMode
    use int.Int

    let function int_to_bounds (min max x: int) : int
        ensures { min <= result <= max }
    =
        if x < min then min else if x > max then max else x

    (* in the JVM, float-to-float operations are round to nearest even for floats and round to zero for float-to-int
       source: https://stackoverflow.com/a/38247753 *)

    val function float64_to_float32_java (x: Float64.t) : Float32.t
        ensures { result = FloatConverter.to_float32 RoundingMode.RNE x }

    val function float32_to_float64_java (x: Float32.t) : Float64.t
        ensures { result = FloatConverter.to_float64 RoundingMode.RNE x }

    val function float32_to_int (x: Float32.t) : int
        ensures { Float32.is_nan x -> result = 0 }
        ensures { not Float32.is_nan x -> result = Float32.to_int RoundingMode.RTZ x }

    val function float64_to_int (x: Float64.t) : int
        ensures { Float64.is_nan x -> result = 0 }
        ensures { not Float64.is_nan x -> result = Float64.to_int RoundingMode.RTZ x }
end

module Primitive
    use Int8
    use Int16
    use UInt16
    use mach.int.Int32
    use mach.int.Int64
    use ieee_float.Float32
    use ieee_float.Float64
    use array.Array
    use int.ComputerDivision
    use prelude.ptr.Ptr
    use export PrimitiveSupport

    type jbool = bool
    type jbyte = Int8.int8
    type jchar = UInt16.uint16
    type jshort = Int16.int16
    type jint = Int32.int32
    type jlong = Int64.int64
    type jfloat = Float32.t
    type jdouble = Float64.t

    (* 
     * Using "snapshot types" to store an immutable structure in the heap.
     * The heap then re-implements mutable operations by mutating the entire copy.
     *)
    type jarraybool = {array bool}
    type jarraybyte = {array Int8.int8}
    type jarraychar = {array UInt16.uint16}
    type jarrayshort = {array Int16.int16}
    type jarrayint = {array Int32.int32}
    type jarraylong = {array Int64.int64}
    type jarrayfloat = {array Float32.t}
    type jarraydouble = {array Float64.t}
    type jarrayptr = {array Ptr.t}

    scope Default
        let constant z: jbool = false
        let constant b: jbyte = 0
        let constant s: jshort = 0
        let constant c: jchar = 0
        let constant i: jint = 0
        let constant j: jlong = 0
        let constant f: jfloat = (0.0:jfloat)
        let constant d: jdouble = (0.0:jdouble) 
    end

    let function d2f (x: jdouble) : jfloat = float64_to_float32_java x
    let function d2i (x: jdouble) : jint = Int32.of_int (int_to_bounds min_int32 max_int32 (float64_to_int x))
    let function d2l (x: jdouble) : jlong = Int64.of_int (int_to_bounds min_int64 max_int64 (float64_to_int x))
    let function dneg (x: jdouble) : jdouble = Float64.neg x
    let function dadd (x y: jdouble) : jdouble = Float64.(.+) x y
    let function dsub (x y: jdouble) : jdouble = Float64.(.-) x y
    let function dmul (x y: jdouble) : jdouble = Float64.(.*) x y
    let function ddiv (x y: jdouble) : jdouble = Float64.(./) x y

    let function f2d (x: jfloat) : jdouble = float32_to_float64_java x
    let function f2i (x: jfloat) : jint = Int32.of_int (int_to_bounds min_int32 max_int32 (float32_to_int x))
    let function f2l (x: jfloat) : jlong = Int64.of_int (int_to_bounds min_int64 max_int64 (float32_to_int x))

    let function i2b (x: jint) : jbyte = Int8.of_int (int_to_bounds min_int8 max_int8 x)
    let function i2c (x: jint) : jchar = UInt16.of_int (int_to_bounds 0 max_uint16 x)
    let function i2s (x: jint) : jshort = Int16.of_int (int_to_bounds min_int16 max_int16 x)
    let function i2l (x: jint) : jlong = Int64.of_int x
    let function i2f (x: jint) : jfloat = Float32.of_int x
    let function i2d (x: jint) : jdouble = Float64.of_int x

    let function l2i (x: jlong) : jint = Int32.of_int (int_to_bounds min_int32 max_int32 x)
    let function l2f (x: jlong) : jfloat = Float32.of_int x
    let function l2d (x: jlong) : jdouble = Float64.of_int x

    (* TODO: implicit in java - insert automatically *)
    let function z2i (x: jbool) : jint = if x then 1 else 0
    let function i2z (x: jint) : jbool = x <> 0




 (*
    dcmp<op>
    drem
    fadd
    fcmp<op>
    fdiv
    fmul
    fneg
    frem
    fsub
    iadd
    iand
    idiv
    if_acmp<cond>
    if_icmp<cond>
    if<cond>
    ifnonnull
    ifnull
    imul
    ineg
    ior
    irem
    ishl
    ishr
    isub
    iushr
    ixor
    ladd
    land
    lcmp
    ldiv
    lmul
    lneg
    lor
    lrem
    lshl
    lshr
    lsub
    lushr
    lxor*)

end
