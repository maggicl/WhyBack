module Program
  (* prelude import *)
  use prelude.ptr.Ptr
  use prelude.typing.Type
  use prelude.heap.HeapDef
  use prelude.heap.Heap
  use export prelude.bootstrap.Bootstrap

  (* primitive types *)
  use prelude.primitive.Int8
  use prelude.primitive.Int16
  use prelude.primitive.UInt16
  use mach.int.Int32
  use mach.int.Int64
  use ieee_float.Float32
  use ieee_float.Float64

  (* class type hierarchy declaration *)

  scope Java
  scope Lang
  scope System
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Lang
  scope CharSequence
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Lang
  scope AutoCloseable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Constant
  scope ConstantDesc
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end
  end

  scope Java
  scope Lang
  scope Constant
  scope Constable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end
  end

  scope GCD
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end

  scope Java
  scope Io
  scope Flushable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Appendable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Io
  scope Closeable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class) && (Class class :> Class Java.Lang.AutoCloseable.class)
  end
  end
  end

  scope Java
  scope Io
  scope OutputStream
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class) && (Class class :> Class Java.Io.Closeable.class) && (Class class :> Class Java.Io.Flushable.class)
  end
  end
  end

  scope Java
  scope Io
  scope FilterOutputStream
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Io.OutputStream.class)
  end
  end
  end

  scope Java
  scope Io
  scope PrintStream
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Io.FilterOutputStream.class) && (Class class :> Class Java.Lang.Appendable.class) && (Class class :> Class Java.Io.Closeable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Comparable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Io
  scope Serializable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Number
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class) && (Class class :> Class Java.Io.Serializable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Integer
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Number.class) && (Class class :> Class Java.Lang.Comparable.class) && (Class class :> Class Java.Lang.Constant.ConstantDesc.class) && (Class class :> Class Java.Lang.Constant.Constable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Throwable
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class) && (Class class :> Class Java.Io.Serializable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope String
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Object.class) && (Class class :> Class Java.Lang.Comparable.class) && (Class class :> Class Java.Lang.Constant.ConstantDesc.class) && (Class class :> Class Java.Lang.Constant.Constable.class) && (Class class :> Class Java.Lang.CharSequence.class) && (Class class :> Class Java.Io.Serializable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope Exception
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Throwable.class)
  end
  end
  end

  scope Java
  scope Lang
  scope RuntimeException
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.Exception.class)
  end
  end
  end

  scope Java
  scope Lang
  scope IllegalArgumentException
    val constant class: Type.class

    axiom hierarchy'8: (Class class :> Class Java.Lang.RuntimeException.class)
  end
  end
  end

  (* class field declaration *)

  scope Java
  scope Lang
  scope System
    scope In
      let constant f: Type.t = Type.unknown (* Class Java.Io.InputStream.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Out
      let constant f: Type.t = Class Java.Io.PrintStream.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Err
      let constant f: Type.t = Class Java.Io.PrintStream.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as I'2NEVER with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as I'2MAYBE with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as AllowSecurityManager with val f = HeapDef.Int, axiom of

    scope Security
      let constant f: Type.t = Type.unknown (* Class Java.Lang.SecurityManager.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Cons
      let constant f: Type.t = Type.unknown (* Class Java.Io.Console.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope InitialErrStream
      let constant f: Type.t = Class Java.Io.PrintStream.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Props
      let constant f: Type.t = Type.unknown (* Class Java.Util.Properties.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope LineSeparator
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope BootLayer
      let constant f: Type.t = Type.unknown (* Class Java.Lang.ModuleLayer.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end
  end
  end
  end

  scope Java
  scope Io
  scope FilterOutputStream
    scope Out
      let constant f: Type.t = Class Java.Io.OutputStream.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as Closed with val f = HeapDef.Int, axiom of

    scope CloseLock
      let constant f: Type.t = Class Java.Lang.Object.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end
  end
  end
  end

  scope Java
  scope Io
  scope PrintStream
    clone prelude.heap.Field as AutoFlush with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as Trouble with val f = HeapDef.Int, axiom of

    scope Formatter
      let constant f: Type.t = Type.unknown (* Class Java.Util.Formatter.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope TextOut
      let constant f: Type.t = Type.unknown (* Class Java.Io.BufferedWriter.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope CharOut
      let constant f: Type.t = Type.unknown (* Class Java.Io.OutputStreamWriter.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as Closing with val f = HeapDef.Int, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope Number
    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope Integer
    clone prelude.heap.Field as I'2MIN_VALUE with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as I'2MAX_VALUE with val f = HeapDef.Int, axiom of

    scope I'2TYPE
      let constant f: Type.t = Type.unknown (* Class Java.Lang.Class.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Digits
      let constant f: Type.t = CharArray
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2DigitTens
      let constant f: Type.t = ByteArray
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2DigitOnes
      let constant f: Type.t = ByteArray
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope SizeTable
      let constant f: Type.t = IntArray
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as Value with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as I'2SIZE with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as I'2BYTES with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope Throwable
    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of

    scope Backtrace
      let constant f: Type.t = Class Java.Lang.Object.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope DetailMessage
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2UNASSIGNED_STACK
      let constant f: Type.t = Type.unknown (* Type.ArrayOf (Class Java.Lang.StackTraceElement.class) *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope Cause
      let constant f: Type.t = Class Java.Lang.Throwable.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope StackTrace
      let constant f: Type.t = Type.unknown (* Type.ArrayOf (Class Java.Lang.StackTraceElement.class) *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as Depth with val f = HeapDef.Int, axiom of

    scope I'2SUPPRESSED_SENTINEL
      let constant f: Type.t = Type.unknown (* Class Java.Util.List.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope SuppressedExceptions
      let constant f: Type.t = Type.unknown (* Class Java.Util.List.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2NULL_CAUSE_MESSAGE
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2SELF_SUPPRESSION_MESSAGE
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2CAUSE_CAPTION
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2SUPPRESSED_CAPTION
      let constant f: Type.t = Class Java.Lang.String.class
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    scope I'2EMPTY_THROWABLE_ARRAY
      let constant f: Type.t = Type.ArrayOf (Class Java.Lang.Throwable.class)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as I'2'024assertionsDisabled with val f = HeapDef.Int, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope String
    scope Value
      let constant f: Type.t = ByteArray
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as Coder with val f = HeapDef.Byte, axiom of

    clone prelude.heap.Field as Hash with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as HashIsZero with val f = HeapDef.Int, axiom of

    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of

    clone prelude.heap.Field as I'2COMPACT_STRINGS with val f = HeapDef.Int, axiom of

    scope SerialPersistentFields
      let constant f: Type.t = Type.unknown (* Type.ArrayOf (Class Java.Io.ObjectStreamField.class) *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as I'2REPL with val f = HeapDef.Char, axiom of

    scope I'2CASE_INSENSITIVE_ORDER
      let constant f: Type.t = Type.unknown (* Class Java.Util.Comparator.class *)
      clone export prelude.heap.PtrField with val f = f, axiom of
    end

    clone prelude.heap.Field as I'2LATIN1 with val f = HeapDef.Byte, axiom of

    clone prelude.heap.Field as I'2UTF16 with val f = HeapDef.Byte, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope Exception
    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope RuntimeException
    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of
  end
  end
  end

  scope Java
  scope Lang
  scope IllegalArgumentException
    clone prelude.heap.Field as SerialVersionUID with val f = HeapDef.Long, axiom of
  end
  end
  end

  (* methods declaration *)

  scope Java
  scope Io
  scope PrintStream
    val println'028Ljava'02Flang'02FString'03B'029V (ghost heap: Heap.t) (this: Ptr.t) (l1: Ptr.t) : unit
      requires { this <> Ptr.null && Heap.instanceof heap this (Class Java.Io.PrintStream.class) }
      requires { Heap.instanceof heap l1 (Class Java.Lang.String.class) }
  end
  end
  end

  scope GCD
    val i'2'03Cinit'03E'028'029V (ghost heap: Heap.t) (this: Ptr.t) : unit
      requires { this <> Ptr.null && Heap.instanceof heap this (Class GCD.class) }

    let predicate result_is_gcd'028SSS'029Z (ghost heap: Heap.t) (l1: jshort) (l2: jshort) (l3: jshort)

    val gcd'028SS'029S (ghost heap: Heap.t) (l1: jshort) (l2: jshort) : jshort

    let predicate arguments_are_positive'028SS'029Z (ghost heap: Heap.t) (l1: jshort) (l2: jshort)

    let function gcd_recursive'028SS'029S (ghost heap: Heap.t) (l1: jshort) (l2: jshort) : jshort

    let predicate arguments_are_negative'028SS'029Z (ghost heap: Heap.t) (l1: jshort) (l2: jshort)
  end

  scope Java
  scope Lang
  scope Object
    val i'2'03Cinit'03E'028'029V (ghost heap: Heap.t) (this: Ptr.t) : unit
      requires { this <> Ptr.null && Heap.instanceof heap this (Class Java.Lang.Object.class) }
  end
  end
  end

  scope Java
  scope Lang
  scope IllegalArgumentException
    val i'2'03Cinit'03E'028Ljava'02Flang'02FString'03B'029V (ghost heap: Heap.t) (this: Ptr.t) (l1: Ptr.t) : unit
      requires { this <> Ptr.null && Heap.instanceof heap this (Class Java.Lang.IllegalArgumentException.class) }
      requires { Heap.instanceof heap l1 (Class Java.Lang.String.class) }
  end
  end
  end

  scope Java
  scope Lang
  scope Integer
    val i'2'03Cinit'03E'028I'029V (ghost heap: Heap.t) (this: Ptr.t) (l1: jint) : unit
      requires { this <> Ptr.null && Heap.instanceof heap this (Class Java.Lang.Integer.class) }
  end
  end
  end
end
